# 如何计算表的数据量

## count(*)来实现

在不同的 MySQL 引擎中，count(*) 有不同的实现方式。*

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。如果带条件的话，MyISAM也是会全表扫描的。
- 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

### InnoDB为什么会全表扫描

这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

### 小结

- MyISAM 表虽然 count(*) 很快，但是不支持事务；*
- show table status 命令虽然返回很快，但是不准确；
- InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。

在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。因此要保证快速，只有自己来计数。

## 用缓存系统保存计数

将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。除非在业务层做分布式事务，但成本太高。

## 在数据库保存计数

把这个计数直接放到数据库里单独的一张计数表 C 中，利用**数据库的事务机制**保证原数据记录数与表C中的计数一致，保证数据一致性。

当系统中频繁查询数据表的记录数的场景，这是**推荐的做法**。

在操作时，应该**先更新数据后更新计数**，原因：先插入新纪录，因为插入新记录只会影响到行锁和间隙锁，而先更新计数表会占用计数表的写锁，而很多其他事务的插入操作就必须阻塞等待。

## 不同count()用法总结

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

- **count(主键 id) ：**InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
-  **count(1) ：**InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- **count(字段)：**1）如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；2）如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
-  **count(*) ：**并不会把全部字段取出来，而是专门做了优化，不取值。直接按行累加。

结论是：按照效率排序的话，**count(字段)<count(主键 id)<count(1)≈count(*)。**

