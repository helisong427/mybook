# 普通索引和唯一索引

二者的区别是唯一索引的索引值必须唯一。查询时二者的性能差别微乎其微，而在更新时，普通索引可以使用到change buffer，以提高更新速度。

## change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

change buffer，实际上它是可以持久化的数据。change buffer 在内存中有拷贝，也会被写入到磁盘上。之所以很快，是因为不需要在海量的原数据页里面查询需要更新的数据。

change buffer 中的操作应用到原数据页，得到最新结果的过程称为 **merge**。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 **innodb_change_buffer_max_size** 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

change buffer非常适用于写多读少的场景，如：账单、日志、备份数据等。

### 唯一索引为什么不能使用

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这**必须要将数据页读入内存才能判断**。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。

## 索引选择

在使用普通索引时，如果数据没有在内存中，使用了change buffer，但是更新后立即进行查询，就会执行change buffer的merge操作，这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

建议如下：

- 这两类索引在查询能力上是没差别的，考虑的是对更新性能的影响。建议尽量选择普通索引。
- 如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer， innodb_change_buffer_max_size 设置为0。
- 在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。

