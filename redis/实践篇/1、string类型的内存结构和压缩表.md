#  string类型的内存结构和压缩表

## string的内存模型

### redisObject

Redis 的数据类型有很多，不同数据类型都有些**相同的元数据**要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 **RedisObject** 结构体来统一记录这些元数据，同时指向实际数据。如下图：

![image-20210720075836358](.\images\image-20210720075836358.png)

redisObject结构占用16字节。

### 简单动态字符串

String 类型保存数据，当保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。

当保存的数据中包含字符时，String 类型就会用**简单动态字符串（Simple Dynamic String，SDS）**结构体来保存，如下图所示：

![image-20210720215437023](.\images\image-20210720215437023.png)

- len：表示buf的使用长度，1字节。
- alloc：表示分配给buf的总长度，1字节。
- flag：表示具体的sds类型，1个字节。
- buf：真正存储数据的地方，肯定有1字节的‘\0’表示结束符。

在 SDS 中，buf 保存实际数据，**SDS额外开销占4字节（len、alloc、flag、buf的结束符）**。

### string存储的3中内存编码模式

redis为了节省内存空间，对string的不同情况有3中不同的编码模式，分别是**int、embstr、raw**，如下图：

![image-20210720080318859](.\images\image-20210720080318859.png)

- **int**：保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。
- **embstr：**保存的字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。
- **raw：**当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。

> 注：为什么是44字节：新版的sds做了优化，len、cap以及新增的flag使用的都是int8类型，只占用1个字节（len、alloc），这样64-16（ReadObj头部）-3（sds头部）-1（buf末尾\0）= 44。

### dictEntry

Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一**个 dictEntry 的结构体**，用来指向一个键值对。如下图：

![image-20210720221951592](.\images\image-20210720221951592.png)

dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节。

jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。**因此dicEntry所占用的空间是32字节**。

### string内存结构

string类型的存储结构是**一个dictEntry指向两个RedisObject，RedisObject根据具体存储数据大小，决定RedisObject的编码模式（int、embstr、raw）。**

例如：10 位数来表示图片 ID 和图片存储对象 ID，使用string类型存储则需要64字节，如下：

```
dictEntry(32B) + 2 * RedisObject(int编码，16B) = 64B
```

其中实际数据只占用16B，其他元数据等开销了48B，额外开销很大。

## 压缩表（ziplist）

Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。list、hash、sorted_set在数据量比较少的时候使用的ziplist，这种数据结构没有指针的开销。

### 压缩表结构

其结构如下：

![image-20210720224024578](.\images\image-20210720224024578.png)

表头有三个字段zlbytes,zltail和zllen, 分别表示长度，列表尾的偏移量，表中entry个数，压缩列表尾还有一个zlend。压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分：

- **prev_len**，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。
- **len**：表示自身长度，4 字节；
- **encoding**：表示编码方式，1 字节；
- **content**：保存实际数据。

Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。

> 我们以保存图片存储对象 ID 为例，来分析一下压缩列表是如何节省内存空间的：每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8=14），实际分配 16 字节。

### 使用hash表存储单值得键值对

在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。

以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。

按照这种设计方法，我在 Redis 中插入了一组图片 ID 及其存储对象 ID 的记录，并且用 info 命令查看了内存开销，我发现，增加一条记录后，内存占用只增加了 16 字节，如下所示：

```
127.0.0.1:6379> info memory
# Memory
used_memory:1039120
127.0.0.1:6379> hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1039136
```

在使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16 字节，所使用的内存空间是原来的 1/4。

Redis Hash 类型的两种底层实现结构，分别是**压缩列表**和**哈希表**。Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：

- hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
- hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。

如果我们往 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。

**二级编码方法中采用的 ID 长度是有讲究的。**为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。

## 小结

在保存的键值对本身占用的内存空间不大时（例如这节课里提到的的图片 ID 和图片存储对象 ID），String 类型的元数据开销就占据主导了，这里面包括了 RedisObject 结构、SDS 结构、dictEntry 结构的内存开销。

针对这种情况，我们可以使用压缩列表保存数据。当然，使用 Hash 这种集合类型保存单值键值对的数据时，我们需要将单值数据拆分成两部分，分别作为 Hash 集合的键和值，就像刚才案例中用二级编码来表示图片 ID，希望你能把这个方法用到自己的场景中。
